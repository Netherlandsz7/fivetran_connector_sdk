name: Require CODEOWNERS Approval

on:
  pull_request:
    types:
      - assigned
      - unassigned
      - labeled
      - unlabeled
      - opened
      - edited
      - closed
      - reopened
      - synchronize
      - ready_for_review
      - locked
      - unlocked
      - review_requested
      - review_request_removed

jobs:
  check-codeowners-approval:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Require CODEOWNER approval if applicable
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.SATVIK_TEST }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });

            const author = pr.data.user.login;
            const assignees = pr.data.assignees.map(a => a.login);

            const files = await github.paginate(
              github.rest.pulls.listFiles,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.data.number,
              }
            );
            const changedFiles = files.map(f => f.filename);

            const codeownersPath = 'CODEOWNERS';
            if (!fs.existsSync(codeownersPath)) {
              console.log('No CODEOWNERS file found. Skipping check.');
              return;
            }

            const codeownersText = fs.readFileSync(codeownersPath, 'utf8');
            const codeownersRules = codeownersText
              .split('\n')
              .filter(line => line.trim() && !line.trim().startsWith('#'))
              .map(line => {
                const [pattern, ...owners] = line.trim().split(/\s+/);
                return { pattern, owners: owners.map(o => o.replace(/^@/, '')) };
              });

            console.log(`Codeowner Rules: ${codeownersRules}`);

            function matches(pattern, filename) {
              if (pattern === "*") {
                return true;
              }
              let regexStr = '^';
              let index = 0;
            
              while (index < pattern.length) {
                if (pattern[index] === '*') {
                  if (pattern[index + 1] === '*') {
                    if (pattern[index + 2] === '/') {
                        regexStr += '(?:.*/)?';
                        index += 3;
                    } else {
                        regexStr += '.*';
                        index += 2;
                    }
                  } else {
                      regexStr += '[^/]*';     
                      index += 1;
                  }
                } else {
                    const c = pattern[index];
                    if ('\\.[]{}()+^$|'.includes(c)) {
                      regexStr += '\\' + c;
                    } else {
                      regexStr += c;
                    }
                    index += 1;
                }
              }
              regexStr += '$';
            
              const regex = new RegExp(regexStr);
              return regex.test(filename);
            }

            const org = context.repo.owner;
            const getTeamMembers = async (slug) => {
              try {
                const members = await github.paginate(
                  github.rest.teams.listMembersInOrg,
                  { org, team_slug: slug }
                );
                return members.map(m => m.login);
              } catch (e) {
                console.log(`Failed to get team ${slug}: ${e.message}`);
                return [];
              }
            };

            const fileToOwnersMap = {};
            for (const file of changedFiles) {
              for (const rule of codeownersRules) {
                if (matches(rule.pattern, file)) {
                  if (!fileToOwnersMap[file]) fileToOwnersMap[file] = new Set();
                  for (const owner of rule.owners) {
                    console.log(`Owner ${owner} for file ${file}`);
                    if (owner.includes('/')) {
                      const [, slug] = owner.split('/');
                      const teamMembers = await getTeamMembers(slug);
                      teamMembers.forEach(m => fileToOwnersMap[file].add(m));
                    } else {
                      fileToOwnersMap[file].add(owner);
                    }
                  }
                  break;
                }
              }
            }

            const reviews = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.data.number,
            });

            const approvedUsers = new Set();
            const latestReview = {};

            for (const review of reviews.data.reverse()) {
              const user = review.user.login;
              if (!latestReview[user]) {
                latestReview[user] = review;
              }
            }

            for (const [user, review] of Object.entries(latestReview)) {
              if (review.state === 'APPROVED') {
                approvedUsers.add(user);
              }
            }

            const filesMissingApproval = [];
            for (const [file, owners] of Object.entries(fileToOwnersMap)) {
              const approved = [...owners].some(o => approvedUsers.has(o));
              if (!approved) {
                filesMissingApproval.push({ file, owners: [...owners] });
              }
            }

            if (filesMissingApproval.length > 0) {
              filesMissingApproval.forEach(f =>
                console.log(`${f.file} needs approval from one of: ${f.owners.join(', ')}`)
              );
              core.setFailed('Missing required CODEOWNER approvals.');
            }

            if (assignees.length === 0) {
              core.setFailed('No assignees set on the PR.');
            }

            const assigneeApproved = assignees.some(
              a => a !== author && approvedUsers.has(a)
            );

            if (!assigneeApproved) {
              core.setFailed('At least one assignee (other than author) must approve the PR.');
            } else {
              console.log('All required CODEOWNER and assignee approvals are present.');
            }
